# 说明
#### 1反编译命令
```

-help 帮助
-l 输出行和变量的表
-public 只输出public方法和域
-protected 只输出public和protected类和成员
-package 只输出包，public和protected类和成员，这是默认的
-p -private 输出所有类和成员
-s 输出内部类型签名
-c 输出分解后的代码，例如，类中每一个方法内，包含java字节码的指令，
-verbose 输出栈大小，方法参数的个数
-constants 输出静态final常量
```
#### 2槽位复用
```
反编译： javap -verbose  TestJVM.class 
    public static void main(String[] args) {
        {
            String a="abc";
            System.out.println(a);
        }
        String b="ddd";
        System.out.println(b);
    }
    
     LocalVariableTable:
        Start  Length  Slot  Name   Signature
            3       7     1     a   Ljava/lang/String;
            0      21     0  args   [Ljava/lang/String;
           13       8     1     b   Ljava/lang/String;
           
     局部变量a超出作用域失效了 b复用它的槽位

```
#### 3TLAB相关
```
为什么需要TLAB？
　　
　　这是为了加速对象的分配。由于对象一般分配在堆上，而堆是线程共用的，因此可能会有多个线程在堆上申请空间，而每一次的对象分配都必须线程同步，会使分配的效率下降。考虑到对象分配几乎是Java中最常用的操作，因此JVM使用了TLAB这样的线程专有区域来避免多线程冲突，提高对象分配的效率。
 
　　局限性： TLAB空间一般不会太大（占用eden区），所以大对象无法进行TLAB分配，只能直接分配到堆上。
　　
　　分配策略：
　　　　一个100KB的TLAB区域，如果已经使用了80KB，当需要分配一个30KB的对象时，TLAB是如何分配的呢？

　  　　 此时，虚拟机有两种选择：第一，废弃当前的TLAB（会浪费20KB的空3.4 间）；第二，将这个30KB的对象直接分配到堆上，保留当前TLAB（当有小于20KB的对象请求TLAB分配时可以直接使用该TLAB区域）。

　　　　JVM选择的策略是：在虚拟机内部维护一个叫refill_waste的值，当请求对象大于refill_waste时，会选择在堆中分配，反之，则会废弃当前TLAB，新建TLAB来分配新对象。

　　　　【默认情况下，TLAB和refill_waste都是会在运行时不断调整的，使系统的运行状态达到最优。】


```
#### 4垃圾回收算法
```
1.复制算法
2.标记清除
3.标记整理(压缩)：所有存活的向一段移动 清除所有存活对象之外的空间 适用于老年代
策略：
分代算法:eg:年轻代(复制)+老年代(标记整理)
分区算法:分成小空间 减少停顿

```




