# 设计模式
### 工厂模式
```
抽象工厂：工厂的工厂(抽象)

```
### 策略模式
```
context持有策略引用和调用策略的方法
具体的策略由具体的实现传递进来

new Context(new 策略具体实现()).调用策略();

优点
  1 算法可以自由切换(传递不同的实现类)
  2 避免使用多重条件判断
  3 扩展性好(扩展时只需传入新的实现类)
缺点
  1 策略类会增多
  2 所有策略都需要对外暴露

```
### 单例
```
1 需要频繁实例化的对象
2 创建对象时耗时/资源过多，但又经常要用到的对象 eg:生成对象需要几万行代码
3 有状态的工具类对象 例如统计QPS的工具类
4 频繁访问数据库或文件的对象

```
静态内部类
```
publc class Singletor{
  /**
  *  解决了线程安全 延迟初始化 
  */
  private  Singletor(){}
  private static Singleton getInstance(){
    return Holder.SINGELE_TON;//
  }
  private static classHolder{
    private static final singleton SINGLE_TON =new Singleton();
  }
}

```
DCL相关问题
```
volatile 禁止指令重排 具体分析
A、 分配新对象的内存
B、 调用类的构造器，初始化成员字段
C、 instance被赋为指向新的对象的引用。

重排后 ACB
禁止重排 ABC 这样就不会出现 获取到 没有初始化的对象

线程A发现instance没有被实例化，它获得锁，然后去实例化该对象，JVM容许在没有完全实例化完成的时候，将实例的指针赋给这个instance变量，而此时instance==null就为false了，在初始化完成之前，线程B进入此方法，发现instance不为空，认为已经初始化完成了，于是便使用了这个尚未完全初始化的实例对象，可能引起其他的异常。

```
