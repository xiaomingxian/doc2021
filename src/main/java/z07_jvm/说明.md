# JVM上

| 堆 | 方法区 | JVM栈 | 本地方法栈 | 程序计数器 |

## 程序计数器:
```记录程序(指令)的跳转```
## 栈：
```
  方法本身:方法内部的代码
  方法内部的变量(基本变量和对象的引用)(基本变量eg:int,short...) #String,对象等都是在堆中，栈中存引用
  #逃逸分析：没有被其他类其他线程引用就是没有逃逸 在栈上分配不走堆 如果堆上分配失败就在堆上(年轻->老年)
 ```
 ## 方法区
 ```
 1.常量，静态变量，即时编译的代码
 
 2.运行时常量池(元数据[类的版本，字段，方法，接口相关信息的描述])
 
 //方法区是常量和静态变量 栈里是变量
 //方法区与永久带的去别：方法区是JVM中的概念,永久带是HotSport对方法区的实现
 //1.8以后用元空间(使用本地内存)取代永久带，之后就见不到方法区溢出
 
 ```
 
 ## 垃圾回收(线程共享区域)
 ```
 1.6以前
 堆(垃圾回收算法)，方法区(不走垃圾回收算法[当内存占用到达MaxMetaSpeace是会进行回收])
 1.8后
 方法区中的常量，静态变量 放到了堆中走垃圾回收算法
 元数据就放到了元空间里 垃圾回收就不需要扫元空间(只需要根据设置的最大值进行回收)
 
 
 ```
 
 # 类加载
 ```
 loadClass(){} //先从缓存中加载 加载不到找父 再找不到调用findClass自定义加载器去加载 //里面是双亲委派的实现 想要打破双亲委派重写此方法即可,但是对系统类的加载不管用,过不了安全校验
 
 findClass(){}
 ```
 ## ContextClassLoader
 ```
 可理解为一个全局变量 默认持有 AppClassLoader
 ```
 ## 打破双亲委派的办法
 ```
 1 重写 LoadClass
 2 使用线程上下文加载器 ContextClassLoader
 
 ```
 
 
