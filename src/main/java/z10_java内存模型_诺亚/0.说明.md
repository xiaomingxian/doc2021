##### 1> 为什么java中的对象都可以作为锁
```
对象头中都有 monitor对象

可从入次数 +1 ...
```

##### 2> 锁的内存语义
```
# 线程间通信
• 线程A释放⼀个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了(线程A 对共享变量所做修改的)消息。
• 线程B获取⼀个锁，实质上是线程B接收了之前某个线程发出的(在释放这个锁之前对共 享变量所做修改的)消息。
• 线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发 送消息。
```

##### 3> volatitle 内存语义
内存屏障+cpu缓存 https://juejin.cn/post/6876395693854949389
```
# 线程间通信
• 线程A写⼀个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程 发出了(其对共享变量所做修改的)消息。
• 线程B读⼀个volatile变量，实质上是线程B接收了之前某个线程发出的(在写这个volatile 变量之前对共享变量所做修改的)消息。
• 线程A写⼀个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过 主内存向线程B发送消息。
```

##### 4> final 内存语义
```

• 在构造函数内对⼀个final域的写⼊，与随后把这个被构造对象的引⽤赋值给⼀个引⽤ 变量，这两个操作之间不能重排序。 # 引用指向的内存地址必有值(先有值后有引用)
• 初次读⼀个包含final域的对象的引⽤，与随后初次读这个final域，这两个操作之间不能 重排序。

写一个final域不能被重排序到构造函数外
读一个final域不能被重排序到读对象引用之前

```
##### 5> 单例：基于类初始化的解决方案
```java
//类的初始化阶段 ：class被加载之后 并且被线程使用之前 会执行类的初始化
//在执行初始化期间 jvm 首先会获取一个锁 这个锁可以同步 多个线程对同一个类的初始化

public class InstanceFactory{
    //初始化 InstanceHolder JVM会保证加锁  
    private static class InstanceHolder{
        //这里的分配空间与初始化对象 是 可以重排序的 但是对外不可见
        private  static  Instance instance=new Instance();
    }
    
    public static Instance getInstance(){
        return InstanceHolder.instance;//会触发 InstanceHolder的初始化 
        // InstanceHolder 中的静态字段被使用 而且该字段不是常量 会触发类的初始化
    }
    
}

//类初始化的情况
//1 T是一个类 而且一个T类型的实例被创建
//2 T中的静态方法被调用
//3 T中的静态字段被赋值
//4 T中的静态字段被使用 而且该字段不是常量

```
