##### 1> 为什么java中的对象都可以作为锁
```
对象头中都有 monitor对象

可从入次数 +1 ...
```

##### 2> 锁的内存语义
```
# 线程间通信
• 线程A释放⼀个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了(线程A 对共享变量所做修改的)消息。
• 线程B获取⼀个锁，实质上是线程B接收了之前某个线程发出的(在释放这个锁之前对共 享变量所做修改的)消息。
• 线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发 送消息。
```

##### 3> volatitle 内存语义
内存屏障+cpu缓存 https://juejin.cn/post/6876395693854949389
```
# 线程间通信
• 线程A写⼀个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程 发出了(其对共享变量所做修改的)消息。
• 线程B读⼀个volatile变量，实质上是线程B接收了之前某个线程发出的(在写这个volatile 变量之前对共享变量所做修改的)消息。
• 线程A写⼀个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过 主内存向线程B发送消息。
```

##### 4> final 内存语义
```

• 在构造函数内对⼀个final域的写⼊，与随后把这个被构造对象的引⽤赋值给⼀个引⽤ 变量，这两个操作之间不能重排序。 # 引用指向的内存地址必有值(先有值后有引用)
• 初次读⼀个包含final域的对象的引⽤，与随后初次读这个final域，这两个操作之间不能 重排序。

写一个final域不能被重排序到构造函数外
读一个final域不能被重排序到读对象引用之前

```
