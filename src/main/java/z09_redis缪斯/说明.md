# Redis

数据类型

#### 1>str
```
内部实现(encoding)
  int :值为long类型的表示的整数 那么encoding是int 
  embstr:值小于等于44时用，专门用来保存段字符串的编码 快
          embstr调用一次分配内存函数来分配一块连续的空间(对象头和值在一块)，包含redisObject,sdshdr 所以速度是最快的
          embstr没有提供修改函数，所以是只读的 测试：对他进行修改 转换成raw,再执行修改
  raw：当值>=44时用(对象头和值是2块区域)

```

#### 2>list
```
ziplist（压缩列表）：当列表的元素个数小于list-max-ziplist-entries配置（默认512个），
    同时列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。
inkedlist（链表）：当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。

----------------------------------
Redis3.2版本提供了quicklist内部编码
quicklist=linkedlist+ziplist
    它将 linkedList 按段切分，每一段使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。
```
#### 3>set
```
intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，Redis会选用intset来作为集合的内部实现，从而减少内存的使用。
hashtable（哈希表）：当集合类型无法满足intset的条件时，Redis会使用hashtable作为集合的内部实现。
```

#### 4>zset 
```
有序集合对象的编码可以是ziplist或者skiplist。同时满足以下条件时使用ziplist编码：
    元素数量小于128个
    所有member的长度都小于64字节
    以上两个条件的上限值可通过zset-max-ziplist-entries和zset-max-ziplist-value来修改。

ziplist编码的有序集合使用紧挨在一起的压缩列表节点来保存，第一个节点保存member，第二个保存score。ziplist内的集合元素按score从小到大排序，score较小的排在表头位置。

skiplist编码的有序集合底层是一个命名为zset的结构体，而一个zset结构同时包含一个字典和一个跳跃表。
    跳跃表按score从小到大保存所有集合元素。而字典则保存着从member到score的映射，这样就可以用O(1)的复杂度来查找member对应的score值。
    虽然同时使用两种结构，但它们会通过指针来共享相同元素的member和score，因此不会浪费额外的内存。
    按缪斯(zhuawa)补充：存储数据
```
#### 5>hash
```
ziplist
hashtable
当hash结构中的数目小于512且key和value的值都是小于64字节时，hash的底层采用的是ziplist，否则采用hashtable数据结构。
```


