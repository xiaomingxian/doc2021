### 分布式锁相关

https://cloud.tencent.com/developer/article/1668123

```
实现要点
    1 加锁和解锁的key一致
    2 不用永久枷锁，设置过期时间
    3 保证加锁和设置过期时间的一致性
    4 要设置过期续租(重入，ThreadLocal)
    
加锁 setnx + 过期时间
解锁 del key 要原子性

```

### 雷区


#### 1>锁过期(业务执行时间长超过了设置的过期时间) -> 锁的续期
```
https://segmentfault.com/a/1190000037526623

发生情况
    业务执行时间长超过了设置的过期时间 锁自动过期

思路参考了redisson：

    保留原先的可自定义设置过期时间，只有在没有设置过期时间（过期时间为默认值0）的情况下，才会启动自动延长。
    申请锁时，设置一个延长过期时间，定时每隔延长过期时间的三分之一时间就重新设置过期时间（时期时间值为延长过期时间）。
    为了防止某次业务由于异常而出现任务持续很久，从而长时间占有了锁，添加最大延期次数参数。
加锁
    用一个Map来存储需要续期的任务信息。
    在加锁成功之后将任务信息放入Map，并启动延迟任务，延迟任务在执行延期动作前先检查下Map里锁数据是不是还是被当前任务持有。
    每次续期任务完成并且成功之后，就再次启动延迟任务。

```

#### 2>重叠解锁
```
发生情况eg:
    A,B 竞争一把锁
                                            8s                                 15s
    A 拿到锁 设置过期时间8s 实际执行了15s 在第8s时锁过期了 锁被释放 
                                                        B拿到锁 设置过期时间15s
                                                                                A的15S到了执行del结果释放了B的锁
 
    .... A解了B锁,B解了C锁 ... # 解锁的雪崩
                                                                                

如果不可重入会有哪些问题
a b c 同时获取了同一个锁
a 解锁会把b 的锁也解了

```
#### 3>单点问题
```
发生情况
    Master存储了锁信息 还未同步到从节点时 Masetr挂了 倒置锁可以被其他线程获取
Redlock算法

```



